jvm
内存模型：堆，方法区。虚拟机栈，本地方法栈，程序计数器。

堆分为新声代，老年代。新声代分为一个eden和两个survior区。

gc回收的是堆和方法区，主要是堆。
标记算法，可达性分析和引用计数器。
引用计数器的缺点：出现两个或多个对象成循环游离状态，造成无法释放。


标记清理：产生大量碎片

标记整理：性能相对要差，stop the world时间长

复制法：会牺牲较多的内存空间。


内存进老年代的条件：
1.大内存会直接进老年代。
2.扛过15岁
3.新声代内存不足
4.新声代gc时，发现某一年龄的对象超过总内存一半，则等于以及超过该年龄的对象会一起移动到老年代。


垃圾收集器
1.serial（复制）和serial old（标记整理）
2.parnew是serial的多线程版本
3.parallel（复制）和parallel old（标记整理）关注点在于吞吐量优先，容忍更多次的gc来提高响应的速度。
4.cms老年代的（标记清除）
初始标记，并发标记，重新标记，并发清除。只有第一和第三部分stop the world
5.g1，将整个堆分成很多个小块，会记录每一个小块的能够回收的内存和回收速度，并作排序，当需要回首时根据排序优先回收效率高的。




类加载器
bootstrap核心加载器，加载jre/lib目录下的
extension加载器加载jre/lib/ext目录下的
application加载器，class.path指定的目录

双亲委派模型

打破模型，继承classloader实现里面的findclass方法

thread.getclassloader

服务器的module



多线程
1.new刚创建出来
2.runnable运行中
3.blocked阻塞，等待锁
4.wait，等待
5.timed_wait 有超时的等待
6.terminated 终止

原子性、可见行、有序性

中断：
stop
interrupted
共享变量

线程间通讯
逻辑控制
wait和notify，唤醒早于等待死锁
suspend和resume，同步会造成死锁，唤醒早于等待死锁
park和unpark，同步死锁

线程池
将一组线程统一管理，减少频繁创建和销毁线程的损耗。

常见线程池：
newsinglethreadexcutor:创建只有一个线程的线程池，串行执行任务。如果因异常导致线程结束，会创建一个新的

fixedthreadexcutor:固定数量的线程池，加一个任务，加一个线程，直到线程达上限，剩下的任务就在任务队列中。如果因异常导致线程关闭，会创建一个新的


cachedthreadexcutor：相对智能的线程池，不设置线程数量，完全由jvm自己决定，当线程数大于任务数时，闲置60s后，会自动关闭多余的线程

scheduedthreadexcutor:不限制线程数量，执行周期或者定时任务

一般不使用Excutors构建线程池，原因是他产生的线程池的队列都是int最大值，会造成oom

一般使用threadpoolexcutor构建线程池，他的几何参数：
核心线程数：不会被关闭的线程数
最大线程数：当任务过多是会创建的线程数
超时时间：超过核心线程数的线程的闲置时间
时间单位：
任务队列：
线程工厂：指定创建哪种线程池
handler：任务数超过线程数和任务队列长度后的拒绝策略。


阻塞队列
有界队列
arrayblockingqueue
linkedblockingqueue


无界队列
priorityblockingqueue 支持优先级排序
delayqueue 使用优先级队列实现的无界队列

synchronousqueue：不存储元素的阻塞队列

linkedtransferqueue 链表无界阻塞

linkedblockingdeque 双向链表无解阻塞队列

add，remove 异常
offer，pull 返boolean
put，take 阻塞







网络
七层模型：物理层，链路层，网络层（ip协议），传输层（tcp，udp），会话层（端口），表示层（传输内容的编码，图片？字符串？），应用层（http，ftp）

三次握手，四次挥手

reactor模型

bio，nio，aio
流是单向的，channel是双向的



zookeeper
节点类型：普通节点，顺序节点，临时节点
临时节点不能有子节点，会话结束就自动释放了

watch机制，根据节点本身，节点数据，子节点的变化通知客户端
watch是一次性的，串行同步的，客户端不会同时处理两个watch


zab协议
崩溃恢复和消息广播


activemq
两种模式：点对点和发布订阅模式
点对点消息不丢失，如果客户端没有成功接受，会保留在mq里

发布订阅模式，mq只会向客户端推送一次，如果失败了就没了，如果想要不丢失，需要消费者配置一个id，并且发送消息时为持久化消息

消息不重复，加一个流水号，消费者收到消息后对流水号判重复

消息防丢，消息进行持久化，堆积消息及时处理，加事务

activemq挂了掉了，持久化消息可以恢复，非持久消息就没了

对于持久化消息太慢，可以打开事务，让非持久化消息走异步效率能提高。



redis
持久化机制，两种方式，rdb以一定的周期策略将内存中的数据以快照形式保存到硬盘中。可以通过配置文件定义快照周期。
aof方式，类似mysql的binlog，把执行过的命令都一一记录下来，然后通过重新执行这些命令来恢复数据。
如果两种方式都开启，默认采用的是aof


缓存雪崩：同一时间大量缓存过期导致都去数据库中获取内容而击穿数据库。两种策略，加锁，分散缓存过期时间，加一个可容忍的随机数。

缓存穿透：访问的很多数据，在缓存和数据库中都没有，导致每次都查一遍缓存又查一遍数据库，最后返回了一个null。解决方案：
1.将所有可能存在的数据的hash值存到一个足够到的bitmap上，那如果一个一定不存在的访问就会被拦截。
2.每次查询之后就算数据库返回null，缓存中也放一个null，只不过让他失效时间相对短一点。


缓存击穿
是指一个热点key失效的瞬间，大量并发打入了数据库。解决办法：在查询数据库之前利用setnx设置一个临时数据，来挡住其他的请求，等查验数据库之后再更新掉临时的数据

缓存预热
如果数据量大可以做一个手动刷新的界面，上线前刷进去
如果数据量小，可以在服务启动的时候加载
设置定时刷新缓存

缓存更新
定时去刷新
缓存失效后去数据库获取


redis和memcache的区别
redis能持久化，停机后重启能恢复，能够做主从备份
value的值可存储内存更大
数据类型更多string list set hash等

redis快的原因：单线程减少上下文切换
非阻塞io，多路复用

redis reactor单线程模型，防止线程被某一个io所阻塞，而阻止了对其他客户端的服务


数据类型
string 正常的存储和计算

set 存放非重复集合，可以方便用于去重操作

hash 存放结构化数据，可以方便取到value中的数据

list 可以用于实现消息队列

sorted set多了一个权重属性，可以用来做排行榜之类的

实现分布式锁：setnx
防死锁，设置超时时间


redis优化：对于压力较大的主库不要做持久化，而是在从库上做持久化
主从库在同一个局域网段
主从采用单向链表的结构


集合
arraylist和vector都是实现了list接口，前者快，后者线程安全。前者扩容时是0.5倍，后者是一倍。都可以设置初始大小，后者可以设置增长的大小。

hashmap和hashtable区别：都实现了map接口，前者key和value可为空，后者不可为空。前者线程不安全，后者线程安全。

hashmap和treemap：前者基于桶，链表，红黑数。后者直接就是红黑树。在迭代时，前者无序后者有序。但性能上前者更加。


concurrenthashmap







spring
模块：core，bean，spring expression language，context容器实现提供ioc功能

aop：提供面向切面的编程实现

jdbc，orm提供持久化框架的接入

transaction 事务支持

jms 支持消息中间件的使用

web用于创建web服务

beanfactory，通过工厂模式实现控制反转，将配置和对象的创建和业务代码剥离

xmlbeanfactory，从xml文件中读取配置和创建对象



注入方式：
构造方法强依赖，set方法用于可选依赖


bean作用域：singleton单例
prototype ：每次获取多创建一个新的




spring的优点：轻量级，控制反转解耦
面向切面分开业务代码和系统控制代码





netty
特点：基于事件驱动的nio框架，高性能
用户可自定义编码与解码操作。自动化的分包和粘包，可自由配置boss和worker两个线程池的大小
责任链模式可以方便用户的使用

知道的序列化协议：json，xml，hessian

netty的零拷贝：直接使用直接内存进行读写，减少了从往堆内存中的二次拷贝



事务：
脏读是指：a事务读到b事务没提交的数据
不可重复读：读到另一个事务更新过的数据
幻读：读到另一个事务删除或插入的数据


隔离机制：
read uncommited：可以读到其他事务没有提交的数据，对应脏读

read commited：只能读其他事务提交过的数据，但会存在不可重复读的问题：也就是在一个事务里对某条数据多次读取，如果同时其他事务修改了该条数据并提交了，就会造成每次读取的数据不一致

repeatable read：允许重复读，也就是一条数据在一个事务里多次读取是相同的，就算其他事务修改了，也读不到。同时还有一个问题，可重复读是对于更新数据而言的，对于新增数据，每次读取还是可能会多会少。

串行：相当于所有的sql都加了for update的锁


事务传播机制：
required，支持当前事务如果没有再创建一个
supports:支持当前事务，如果没有，就不使用事务

mandatory:强制使用当前事务，如果不存在抛异常

requires_new：必须创建一个新的，如果有了挂起

not_supported:不支持，如果有事务，把事务挂起

never:如果有事务，抛异常

nested:嵌套，如果当前有了，执行嵌套，如果当前没有创建一个新的


