&ensp;&ensp;&ensp;&ensp;有时候我们需要对对用户进行多维度的获取,eg:获取男性用户列表，获取会员用户列表，获取有xx性质的用户列表，这些多维度性质一般都保存在数据库中，我们可以通过sql很方便的查询，另一方面由于这些特性都不是频繁更改的特性，在落库时也没有很大的压力。而用户的在线状态，在很多系统中可能也没有落库压力，根据心跳包来判断用户是否在线，如果心跳停止了，则认为用户下线然后状态落库，但是我们系统底层架构设计不允许这么做，因为后端业务服务器和客户端不直接建立长连接，全部提供restful接口，那没有长连接怎么实现消息推送呢，架构图如下：
![公司网络拓扑图.jpg](..\picture_back_up\公司网络拓扑图.jpg)
业务服务器通过redis的进行发布消息，然后socket服务器订阅后推送给客户端，从而实现将长连接与业务服务器剥离，降低业务服务器的压力。那业务端如何判断用户是否在线呢，当用户调用接口时，在接口的拦截器里进行redis修改，set一个redis key，超时时间为三分钟，也就是三分钟没有发生新的接口调用则认为用户下线了。然后也不修改数据库，这样用户是否在线，只能根据redis key来判断，原有的业务中也能满足，但是最近新增的用户推荐和附近的人的功能，都需要从在线用户中去筛选用户，如果数据库中没有用户在线状态，则没有办法进行筛选。所以只能修改这个简单的用户在线标记的算法。

1. 通过redis的getset来判断是否上线，通过redis的过期监听来判断是否线下，然后对应修改数据库的状态，这种对数据库的操作其实不会很频繁，但是与运维沟通后发现，如果监听redis的key过期，由于redis的单线程，如果一下子有大量的key同时过期，redis就直接卡住了，而redis又不能指定监听某一个key的过期，所以这种设计被毙了。

2. 通过redis的zset来设计，当有用户上线时zadd到zset中，分数为当前时间戳，如果zadd是插入不是更新，则表示用户上线，如果zadd是更新，则只更新redis zset里的分数。然后另外起一个每三分钟的定时脚本，将zset中分数为（0，三分钟以前的时间戳）的用户给删除，删除前先修改数据库中的状态为下线。这种策略有一个问题的就是大key，随着服务的增大，在线用户的增多，zset会越来越庞大，所以可以根据用户的userId进行拆分，由于我们的userId是递增的，假设当前用户id为500001，评估下来每20万个用户中有1万在线用户，则我们可以划分多个zset的key,eg:online_user:200000，online_user:400000，online_user:600000，online_user:800000，我们预留到800000，当用户达到80万时，再进行优化扩大。目前采取的当前方法进行的实现，其实后来思考，还有更好的设计，见方案3。

3. 看拓扑图中，既然socket服务器进行的长连接，则可以获取到用户是否在线，当用户不在线时，向业务服务器推送一个mq，然后业务服务器根据消息进行修改库和redis，这样业务服务器既可以不承担长连接的开销，又可以实时获取到用户的状态。