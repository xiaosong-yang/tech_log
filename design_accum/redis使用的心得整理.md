1. 使用redis的hash数据结构时，尽量不要使用hgetall，这个命令会从指定key中把所有的键值对全部取出，如果数据量但很影响性能，所以当需要获取的key和hashkey明确时，请直接获取具体的值，不要将整个hash取出来。

2. 对于redis中的数据总量无上限或者上限超过承受范围的数据，一定要做清理，不要无限制的往里面塞，否则早晚会炸掉。一般清理的两种方式：（1）定时脚本清理；（2）每次接口中对历史数据进行清理


3. 使用redis时能用字符串则用字符串，能用bitmap则用bitmap，如果使用hash，set，zset，list一定要注意大key问题，大key在redis进行数据迁移和扩容时会产生卡顿。

4. 不要使用redis的multi，exec这样的事务，因为redis的一个链接同一时刻只能存在一个事务，也就是会造成其他线程的事务崩溃，如果要保证redis多条命令的一致性只能使用lua脚本，并且由于redis的单线程特质，lua脚本能同时保证原子性。

5. 基于第四点的redis保证lua脚本的原子性，所以lua脚本中不能有耗时操作，会导致所有其他的redis请求全部被阻塞。

6. redis本质是没有像mysql那样需要commit的事务的，也就是一旦redis在要执行的lua脚本中的某两条命令之间崩溃了，执行的第一条命令也没有办法回滚，但是我们考虑这种情况，redis认为这种情况不会发生。就像我们在java程序中执行不调用第三方中间件的两条命令时，是不考虑这两条命令之间会不会崩溃的，认为这种情况不会发生。

7. 由于redis不具备事务回滚能力，所以redis的写操作一般放在整个流程的最后面，以保证数据与数据库得一致性。因为redis执行失败后，可以将数据库的操作回滚掉，而如果先写redis，再写mysql，一旦mysql写失败了，写到redis的内容无法回滚。

8. redis的set相关命令比如：set，mset，getset之类的是会使之前设置的过期时间失效，需要重新设置过期时间。而诸如incr，incrby之类的非set命令不会导致过期时间失效。