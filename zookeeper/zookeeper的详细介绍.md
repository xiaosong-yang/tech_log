# zk的配置介绍
&ensp;&ensp;&ensp;&ensp;我们打开上一章安装时介绍的conf目录下的zoo.cfg文件，我们可以看到有几项显而易见的配置项：tickTime、initLimit、syncLimit、dataDir、clientPort，其中initLimit和syncLimit和zk集群相关，等到了讲集群的地方再介绍。

 - tickTime：是zk用于计算时的最小时间单位，单位为毫秒，tickTime=2000，表示最小时间单位为两秒。什么叫最小时间单位，即其他和时间有关的配置项都是tickTime的倍数。
 - dataDir：zk的数据都是会落入硬盘进行持久化的，重启时数据不会丢失，而dataDir即为zk保存数据的目录。
 - clientPort：zk的服务端端口，客户端连接服务端时填写的端口号。

# zk的节点类型
&ensp;&ensp;&ensp;&ensp;上一章说到zk利用节点记录数据，而zk的节点是没有相对路径的，只有绝对路径，根路径为/，所以每次访问某一个节点，加入根路径下的zk1节点，你要/zk1，如果zk1节点下的zk11节点，你要/zk1/zk11，这样来访问。另外zk的节点可以从两个维度进行分类，一个是（临时/持久）,一个是（有序/无序）。

- 临时节点：临时节点表示当这个节点创造者（某一台客户端）与服务端的会话失效之后，这个临时节点就会从zk上去除。创建临时节点通过create命令后面加上-e来实现，eg：创建一个zk_linshi节点，里面村存放124这么一个数据
>  create -e /zk_linshi 124

- 持久节点：持久节点顾名思义，创建之后这个节点会一直存在，直到手动删除为止。zk的create命令不加-e，默认创建的就是持久节点。
- 有序节点：有序节点表示节点会存在顺序，通过create命令加-s来创建，eg：
> 命令：
> create -s /zk 32432
> 返回：
> Created /zk0000000001
> 命令：
> create -s /zk_haha 45345
> 返回：
> Created /zk_haha0000000002
> 命令：
> create -s /zk/zk22 fsss
> 返回：
> Created /zk/zk220000000000

&ensp;&ensp;&ensp;&ensp;我们创建了zk和zk_haha两个节点，而实际创建出来的是zk0000000001和zk_haha0000000002这两个节点。可以看到他在我们原本节点名字上，后面补了一个十位的数字，并且两次创建所补的数字还是递增的，这就是有序节点的含义。他所补的数字最大直到4字节int的最大值（2147483647），如果超过这个值，将会溢出。而我们创建/zk/zk22 这个节点时，所创建出来的子节点又回到了0000000000，所以跨节点后这个顺序不再共用。而zk有序节点的根本原因是，zk的每一个节点下都有一个计数器，当要在这个节点下创建有序节点时，计数器进行累加。

- 无序节点：无序节点其实就是我们普通创建的节点，创建时叫什么名字，产生的就是什么名字，zk的create命令不加-s默认创建的就是无序节点。


# zk的watch监听机制
## watch监听中的三个方法
- getData：获取当前节点的数据变化
- exists：获取当前节点是否存在的变化
- getChildren：获取当前节点的子节点变化（不包括子节点的数据变化）

## watch触发监听的四类事件
- created event：节点的创建，会触发getData方法
- deleted event：节点的删除，会触发getData，exists，getChildren，很好理解，节点删除了，节点的数据和子节点都没有了，自然而然三个都会触发
- changed event：节点的变化，会触发getData，exists
- child event：子节点变化，会触发getChildren

## watch的两个特性
- 一次性：watch一旦触发，就会被删除，如果需要持续监听，需要不断重新设置watch
- 有序性：客户端先得到watch通知，之后才会看到变化，如果没有收到watch通知，客户端是看不到变化的

## 使用watch的注意点

 1. watch是一次性的，所以想要持续监听，必须不断重新设置新的watch
 2. 利用watch进行持续监听，不能可靠的得到节点发生的所有变化，原因是你上一次watch被删除到重新设置新watch这段时间，存在时间延迟，所以这段时间发生的变化，是无法监听到的
3. watch虽然只会被触发一次，但是涉及到的监听都会被出发到，比如deleted时间会触发exists，getData，getChildren三个监听，那这个三都会被触发到一次。



# zk的权限控制
&ensp;&ensp;&ensp;&ensp;上一章最后降到了一个ACL这个概念，他是zk节点的权限控制，他能且只能控制当前设置的节点权限，不能对该节点的子节点进行控制，更不具备递归性（linux上权限如果不是可以设置的话是递归的，需要区分一下）。一个ACL权限，由三部分构成{scheme:expression,perms}组成，scheme表示权限控制策略，expression为一个表达式，表示被授权的对象的集合，perms表示被授予的是哪几种权限。

###  scheme策略类型
&ensp;&ensp;&ensp;&ensp;ACL中有以下几种策略类型：

- world：这种策略下，expression只有一个：anyone，表示任何人，也是zk的默认策略。
- auth：不需要设置expression，通过addauth命令添加认证用户，经过认证的用户具有权限。
- digest：zk服务端通过明文设置，客户端使用username:base64(md5(password))串进行访问。
- ip：使用客户端主机ip作为访问策略。addr/bit ,其中addr表示地址段，bit表示段后面的位数。eg：(ip:19.22.0.0/16,READ)表示，以19.22开头的所有客户端都具有该节点的读取权限。

### perms权限类型
&ensp;&ensp;&ensp;&ensp;ACL中有以下集中权限类型：

- CREATE：创建子节点权限，简称c
- READ：读取节点数据和字节信息的权限，简称r
- WRITE：修改节点数据的权限，简称w
- DELETE：删除子节点的权限，简称d
- ADMIN：设置节点权限访问列表的权限，简称a


# zk的总体特性

 1. 顺序一致性，保证客户端的操作都是按顺序执行的。
 2. 原子性，要么成功要么失败，不会出现部分成功。
 3. 对于zk集群，不管客户端连接的集群中的哪一台，看到的内容都是一样的。
 4. 可靠性，数据不会被变更或丢失，除非被客户端自己修改了。
 5. 及时性，客户端读取的肯定是最新的，不会有什么缓存的说法。

